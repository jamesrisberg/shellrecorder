#!/usr/bin/env python3
"""clauderec — render Claude Code transcripts, merge with terminal recordings"""

import json
import re
import sys
import os
from datetime import datetime


def format_timestamp(ts):
    try:
        dt = datetime.fromisoformat(ts.replace("Z", "+00:00"))
        return dt.strftime("%Y-%m-%d %H:%M")
    except (ValueError, AttributeError):
        return ts


def render_tool_use(block):
    name = block["name"]
    inp = block.get("input", {})

    if name == "Read":
        return f"> **Read** `{inp.get('file_path', '')}`"
    if name == "Write":
        return f"> **Write** `{inp.get('file_path', '')}`"
    if name == "Edit":
        path = inp.get("file_path", "")
        old = inp.get("old_string", "")[:60].replace("\n", "\\n")
        return f"> **Edit** `{path}` — `{old}…`"
    if name == "Glob":
        return f"> **Glob** `{inp.get('pattern', '')}` in `{inp.get('path', '.')}`"
    if name == "Grep":
        return f"> **Grep** `{inp.get('pattern', '')}` in `{inp.get('path', '.')}`"
    if name == "Bash":
        cmd = inp.get("command", "")[:120]
        return f"> **Bash** `{cmd}`"
    if name == "Task":
        desc = inp.get("description", "")
        return f"> **Task** _{desc}_"
    if name == "LSP":
        op = inp.get("operation", "")
        path = inp.get("filePath", "")
        return f"> **LSP** `{op}` on `{path}`"

    parts = ", ".join(f"{k}={json.dumps(v)[:80]}" for k, v in inp.items())
    return f"> **{name}** `{parts}`"


def render_tool_result(content):
    if isinstance(content, str):
        text = content
    elif isinstance(content, list):
        text = "\n".join(
            c.get("text", "") for c in content if isinstance(c, dict) and c.get("type") == "text"
        )
    else:
        return ""

    lines = text.strip().split("\n")
    if len(lines) > 20:
        preview = "\n".join(lines[:10] + [f"  … ({len(lines) - 10} more lines)"])
    else:
        preview = "\n".join(lines)
    return preview


def find_jsonl(session_id):
    claude_dir = os.path.expanduser("~/.claude/projects")
    if not os.path.isdir(claude_dir):
        return None
    for root, dirs, files in os.walk(claude_dir):
        for f in files:
            if f == f"{session_id}.jsonl":
                return os.path.join(root, f)
    return None


def render_session(path):
    """Render a JSONL transcript to a list of markdown lines."""
    messages = []
    meta = {}

    with open(path) as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            obj = json.loads(line)
            t = obj.get("type")

            if t == "user":
                msg = obj["message"]
                content = msg.get("content", "")
                if isinstance(content, list):
                    for block in content:
                        if block.get("type") == "tool_result":
                            result_text = render_tool_result(block.get("content", ""))
                            if result_text:
                                messages.append(("tool_result", result_text))
                    continue
                if isinstance(content, str) and content.strip():
                    ts = format_timestamp(obj.get("timestamp", ""))
                    messages.append(("user", content.strip(), ts))

            elif t == "assistant":
                blocks = obj["message"].get("content", [])
                ts = format_timestamp(obj.get("timestamp", ""))
                model = obj["message"].get("model", "")
                if not meta.get("model") and model:
                    meta["model"] = model
                if not meta.get("start"):
                    meta["start"] = ts
                for block in blocks:
                    bt = block.get("type")
                    if bt == "text":
                        text = block.get("text", "").strip()
                        if text:
                            messages.append(("assistant_text", text))
                    elif bt == "tool_use":
                        messages.append(("tool_use", render_tool_use(block)))
                meta["end"] = ts

    out = []
    session_id = os.path.splitext(os.path.basename(path))[0]
    model = meta.get("model", "unknown")
    started = meta.get("start", "")
    out.append(f"### Claude Code — {model}")
    if started:
        out.append(f"*Session started {started}* · `{session_id}`\n")

    last_type = None
    for item in messages:
        kind = item[0]
        if kind == "user":
            _, text, ts = item
            if last_type and last_type != "user":
                out.append("---\n")
            out.append(f"**User:** {text}\n")
            last_type = "user"
        elif kind == "assistant_text":
            _, text = item
            out.append(f"{text}\n")
            last_type = "assistant_text"
        elif kind == "tool_use":
            _, summary = item
            out.append(f"{summary}\n")
            last_type = "tool_use"
        elif kind == "tool_result":
            _, preview = item
            if preview:
                out.append(f"```\n{preview}\n```\n")
            last_type = "tool_result"

    return "\n".join(out)


def merge(clean_text_path):
    """Merge a cleaned terminal recording with any Claude Code sessions found in it."""
    with open(clean_text_path) as f:
        lines = f.read().split("\n")

    # Find all claude --resume markers
    markers = []
    for i, line in enumerate(lines):
        m = re.search(r"claude --resume ([0-9a-f-]{36})", line)
        if m:
            markers.append((i, m.group(1)))

    if not markers:
        # No Claude sessions — return the clean text as-is
        return "\n".join(lines)

    # Build segments: (type, content)
    segments = []
    last_end = 0

    for marker_line, session_id in markers:
        # Find where Claude was launched: scan backwards for a prompt line ending with `claude`
        start = marker_line
        for i in range(marker_line - 1, last_end - 1, -1):
            if re.search(r"[%$#>]\s*claude\b", lines[i]):
                start = i
                break

        # Terminal section before this Claude session
        terminal_lines = lines[last_end:start]
        terminal_text = "\n".join(terminal_lines).strip()
        if terminal_text:
            segments.append(("terminal", terminal_text))

        # Claude session
        jsonl = find_jsonl(session_id)
        if jsonl:
            segments.append(("claude", render_session(jsonl)))
        else:
            # Couldn't find JSONL — keep original text
            segments.append(("terminal", "\n".join(lines[start : marker_line + 1]).strip()))

        # Advance past the marker line
        last_end = marker_line + 1

    # Terminal section after the last Claude session
    terminal_text = "\n".join(lines[last_end:]).strip()
    if terminal_text:
        segments.append(("terminal", terminal_text))

    # Render merged output
    parts = []
    for kind, content in segments:
        if kind == "terminal":
            parts.append(f"```\n{content}\n```")
        elif kind == "claude":
            parts.append(content)

    return "\n\n".join(parts) + "\n"


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: clauderec <session.jsonl|session-id>", file=sys.stderr)
        print("       clauderec --merge <recording.txt>", file=sys.stderr)
        sys.exit(1)

    if sys.argv[1] == "--merge":
        if len(sys.argv) < 3:
            print("Usage: clauderec --merge <recording.txt>", file=sys.stderr)
            sys.exit(1)
        print(merge(sys.argv[2]), end="")
    else:
        arg = sys.argv[1]
        if os.path.isfile(arg):
            print(render_session(arg))
        else:
            jsonl = find_jsonl(arg)
            if jsonl:
                print(render_session(jsonl))
            else:
                print(f"No JSONL found for session: {arg}", file=sys.stderr)
                sys.exit(1)
