#!/usr/bin/env bash
# rec — record a terminal session to a clean text file
# Usage: rec [filename]

set -euo pipefail

if [ -n "${_SHELLREC:-}" ]; then
  printf 'Already recording.\n'
  exit 1
fi

recdir="$HOME/.shellrecorder/recordings"
mkdir -p "$recdir"

file="${1:-rec_$(date +%Y%m%d_%H%M%S).txt}"
[[ "$file" != /* ]] && file="$recdir/$file"

tmp=$(mktemp "${TMPDIR:-/tmp}/shellrec.XXXXXX")
rcdir=$(mktemp -d "${TMPDIR:-/tmp}/shellrec_rc.XXXXXX")
shell_name=$(basename "$SHELL")

rawfile="${file%.txt}.raw"

cleanup() { rm -rf "$rcdir"; }
trap cleanup EXIT

# Snippet injected into the recording subshell
snippet='stoprec() { exit; }
rec() { printf "Already recording.\n"; return 1; }'

case "$shell_name" in
  zsh)
    real_zdotdir="${ZDOTDIR:-$HOME}"
    for f in .zshenv .zprofile .zlogin .zlogout; do
      [ -f "$real_zdotdir/$f" ] && ln -s "$real_zdotdir/$f" "$rcdir/$f"
    done
    cat > "$rcdir/.zshrc" << INNER
[ -f '${real_zdotdir}/.zshrc' ] && source '${real_zdotdir}/.zshrc'
${snippet}
INNER
    ;;
  bash)
    cat > "$rcdir/.bashrc" << INNER
[ -f '${HOME}/.bashrc' ] && source '${HOME}/.bashrc'
${snippet}
INNER
    ;;
esac

printf 'Recording → %s\n' "$file"
printf 'Type "stoprec" when done.\n'

# Start recording
case "$shell_name" in
  zsh)
    ZDOTDIR="$rcdir" _SHELLREC=1 script -q "$tmp" || true
    ;;
  bash)
    if [ "$(uname -s)" = "Darwin" ]; then
      _SHELLREC=1 script -q "$tmp" bash --rcfile "$rcdir/.bashrc" || true
    else
      _SHELLREC=1 script -qc "bash --rcfile '$rcdir/.bashrc'" "$tmp" || true
    fi
    ;;
  *)
    printf '(stoprec unavailable in %s — type "exit" to stop)\n' "$shell_name"
    _SHELLREC=1 script -q "$tmp" || true
    ;;
esac

# Strip escape sequences, process carriage returns, and clean backspaces
perl -pe '
  s/\e\[ [?>=<]* [0-9;]* [a-zA-Z~]//gx;   # CSI sequences (colors, modes, cursor)
  s/\e\] .*? (?:\a|\e\\)//gx;              # OSC sequences (titles, hyperlinks)
  s/\e[()][A-Z0-9]//g;                     # charset selection
  s/\e[a-zA-Z]//g;                         # two-char escapes
  s/^.*\r(?!\n)//;                          # carriage return overwrites (PROMPT_EOL_MARK etc)
  s/\r//g;                                  # remaining \r
' < "$tmp" | col -b > "$file"

cp "$tmp" "$rawfile"
rm -f "$tmp"

printf 'Saved → %s (%s lines)\n' "$file" "$(wc -l < "$file" | tr -d ' ')"
printf 'Raw   → %s\n' "$rawfile"

# Detect Claude Code sessions and extract clean transcript
session_id=$(grep -oE 'claude --resume [0-9a-f-]{36}' "$file" "$rawfile" 2>/dev/null | head -1 | grep -oE '[0-9a-f-]{36}')
if [ -n "$session_id" ]; then
  jsonl=$(find "$HOME/.claude/projects" -name "${session_id}.jsonl" 2>/dev/null | head -1)
  if [ -n "$jsonl" ]; then
    mdfile="${file%.txt}.md"
    rec_dir="$(cd "$(dirname "$0")" && pwd)"
    if [ -x "$rec_dir/clauderec" ]; then
      "$rec_dir/clauderec" "$jsonl" > "$mdfile"
    elif command -v clauderec >/dev/null 2>&1; then
      clauderec "$jsonl" > "$mdfile"
    else
      python3 -c '
import json, sys, os

def render(path):
    print("# Claude Code Session\n")
    with open(path) as f:
        for line in f:
            obj = json.loads(line)
            t = obj.get("type")
            if t == "user":
                msg = obj["message"]
                content = msg.get("content", "")
                if isinstance(content, str) and content.strip():
                    print(f"## User\n\n{content.strip()}\n")
            elif t == "assistant":
                for block in obj["message"].get("content", []):
                    if block["type"] == "text" and block.get("text", "").strip():
                        print(block["text"].strip() + "\n")
                    elif block["type"] == "tool_use":
                        name = block["name"]
                        inp = block.get("input", {})
                        summary = ", ".join(f"{k}={json.dumps(v)[:80]}" for k, v in inp.items())
                        print(f"**{name}** `{summary}`\n")

render(sys.argv[1])
' "$jsonl" > "$mdfile"
    fi
    printf 'Claude → %s\n' "$mdfile"
  fi
fi
